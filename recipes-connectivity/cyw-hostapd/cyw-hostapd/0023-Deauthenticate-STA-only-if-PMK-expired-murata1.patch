From 07c981fe38e527af1020a4b124828fbaf3fb8472 Mon Sep 17 00:00:00 2001
From: Kurt Lee <kurt.lee@cypress.com>
Date: Mon, 28 Mar 2022 03:53:29 -0500
Subject: [PATCH 23/23] Deauthenticate STA only if PMK expired

Porting from commit 6aaac006af7fd39d618c6546939bed9f0f0cea37
which acts on hostapd. Don't deauthenticate STA when PMK is freed or
replaced
---
 src/ap/pmksa_cache_auth.c | 22 ++++++++++++----------
 src/ap/pmksa_cache_auth.h | 12 ++++++++++--
 src/ap/wpa_auth.c         |  7 ++++---
 3 files changed, 26 insertions(+), 15 deletions(-)

diff --git a/src/ap/pmksa_cache_auth.c b/src/ap/pmksa_cache_auth.c
index fe5f81717..8cfd43b47 100644
--- a/src/ap/pmksa_cache_auth.c
+++ b/src/ap/pmksa_cache_auth.c
@@ -28,7 +28,8 @@ struct rsn_pmksa_cache {
 	struct rsn_pmksa_cache_entry *pmksa;
 	int pmksa_count;
 
-	void (*free_cb)(struct rsn_pmksa_cache_entry *entry, void *ctx);
+	void (*free_cb)(struct rsn_pmksa_cache_entry *entry, void *ctx,
+			enum pmksa_free_reason reason);
 	void *ctx;
 };
 
@@ -49,13 +50,14 @@ static void _pmksa_cache_free_entry(struct rsn_pmksa_cache_entry *entry)
 
 
 void pmksa_cache_free_entry(struct rsn_pmksa_cache *pmksa,
-			    struct rsn_pmksa_cache_entry *entry)
+			    struct rsn_pmksa_cache_entry *entry,
+			    enum pmksa_free_reason reason)
 {
 	struct rsn_pmksa_cache_entry *pos, *prev;
 	unsigned int hash;
 
 	pmksa->pmksa_count--;
-	pmksa->free_cb(entry, pmksa->ctx);
+	pmksa->free_cb(entry, pmksa->ctx, reason);
 
 	/* unlink from hash list */
 	hash = PMKID_HASH(entry->pmkid);
@@ -101,7 +103,7 @@ void pmksa_cache_auth_flush(struct rsn_pmksa_cache *pmksa)
 	while (pmksa->pmksa) {
 		wpa_printf(MSG_DEBUG, "RSN: Flush PMKSA cache entry for "
 			   MACSTR, MAC2STR(pmksa->pmksa->spa));
-		pmksa_cache_free_entry(pmksa, pmksa->pmksa);
+		pmksa_cache_free_entry(pmksa, pmksa->pmksa, PMKSA_FREE);
 	}
 }
 
@@ -115,13 +117,12 @@ static void pmksa_cache_expire(void *eloop_ctx, void *timeout_ctx)
 	while (pmksa->pmksa && pmksa->pmksa->expiration <= now.sec) {
 		wpa_printf(MSG_DEBUG, "RSN: expired PMKSA cache entry for "
 			   MACSTR, MAC2STR(pmksa->pmksa->spa));
-		pmksa_cache_free_entry(pmksa, pmksa->pmksa);
+		pmksa_cache_free_entry(pmksa, pmksa->pmksa, PMKSA_EXPIRE);
 	}
 
 	pmksa_cache_set_expiration(pmksa);
 }
 
-
 static void pmksa_cache_set_expiration(struct rsn_pmksa_cache *pmksa)
 {
 	int sec;
@@ -374,14 +375,14 @@ int pmksa_cache_auth_add_entry(struct rsn_pmksa_cache *pmksa,
 	 */
 	pos = pmksa_cache_auth_get(pmksa, entry->spa, NULL);
 	if (pos)
-		pmksa_cache_free_entry(pmksa, pos);
+		pmksa_cache_free_entry(pmksa, pos, PMKSA_REPLACE);
 
 	if (pmksa->pmksa_count >= pmksa_cache_max_entries && pmksa->pmksa) {
 		/* Remove the oldest entry to make room for the new entry */
 		wpa_printf(MSG_DEBUG, "RSN: removed the oldest PMKSA cache "
 			   "entry (for " MACSTR ") to make room for new one",
 			   MAC2STR(pmksa->pmksa->spa));
-		pmksa_cache_free_entry(pmksa, pmksa->pmksa);
+		pmksa_cache_free_entry(pmksa, pmksa->pmksa, PMKSA_FREE);
 	}
 
 	pmksa_cache_link_entry(pmksa, entry);
@@ -538,7 +539,8 @@ struct rsn_pmksa_cache_entry * pmksa_cache_get_okc(
  */
 struct rsn_pmksa_cache *
 pmksa_cache_auth_init(void (*free_cb)(struct rsn_pmksa_cache_entry *entry,
-				      void *ctx), void *ctx)
+				      void *ctx, enum pmksa_free_reason reason),
+		      void *ctx)
 {
 	struct rsn_pmksa_cache *pmksa;
 
@@ -612,7 +614,7 @@ int pmksa_cache_auth_radius_das_disconnect(struct rsn_pmksa_cache *pmksa,
 			found++;
 			prev = entry;
 			entry = entry->next;
-			pmksa_cache_free_entry(pmksa, prev);
+			pmksa_cache_free_entry(pmksa, prev, PMKSA_FREE);
 			continue;
 		}
 		entry = entry->next;
diff --git a/src/ap/pmksa_cache_auth.h b/src/ap/pmksa_cache_auth.h
index 2ef217435..9c942024d 100644
--- a/src/ap/pmksa_cache_auth.h
+++ b/src/ap/pmksa_cache_auth.h
@@ -34,12 +34,19 @@ struct rsn_pmksa_cache_entry {
 	u64 acct_multi_session_id;
 };
 
+enum pmksa_free_reason {
+	PMKSA_FREE,
+	PMKSA_REPLACE,
+	PMKSA_EXPIRE,
+};
+
 struct rsn_pmksa_cache;
 struct radius_das_attrs;
 
 struct rsn_pmksa_cache *
 pmksa_cache_auth_init(void (*free_cb)(struct rsn_pmksa_cache_entry *entry,
-				      void *ctx), void *ctx);
+				      void *ctx, enum pmksa_free_reason reason),
+		      void *ctx);
 void pmksa_cache_auth_deinit(struct rsn_pmksa_cache *pmksa);
 struct rsn_pmksa_cache_entry *
 pmksa_cache_auth_get(struct rsn_pmksa_cache *pmksa,
@@ -68,7 +75,8 @@ void pmksa_cache_to_eapol_data(struct hostapd_data *hapd,
 			       struct rsn_pmksa_cache_entry *entry,
 			       struct eapol_state_machine *eapol);
 void pmksa_cache_free_entry(struct rsn_pmksa_cache *pmksa,
-			    struct rsn_pmksa_cache_entry *entry);
+			    struct rsn_pmksa_cache_entry *entry,
+			    enum pmksa_free_reason reason);
 int pmksa_cache_auth_radius_das_disconnect(struct rsn_pmksa_cache *pmksa,
 					   struct radius_das_attrs *attr);
 int pmksa_cache_auth_list(struct rsn_pmksa_cache *pmksa, char *buf, size_t len);
